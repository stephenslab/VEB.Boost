% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/veb_boost.R
\name{veb_boost_stumps}
\alias{veb_boost_stumps}
\title{Wrapper for using VEB-Boost with the SER prior w/ stumps and/or linear terms}
\usage{
veb_boost_stumps(
  X,
  Y,
  X_test = NULL,
  include_linear = TRUE,
  include_stumps = TRUE,
  num_cuts = 100,
  ...
)
}
\arguments{
\item{X}{An (n x p) numeric matrix to be used as the predictors (currently, this wrapper forces all nodes to use the same X)}

\item{Y}{is a numeric vector response}

\item{X_test}{is an (m X p) matrix to be used as the testing data. Posterior mean response is saved in the output's field `$pred_mu1`}

\item{include_linear}{is a logical of length 1 or p specifying which columns of X we should include as linear terms.
If the length is 1, this value gets recycled for all columns of X.}

\item{include_stumps}{is a logical of length 1 or p specifying which columns of X we should include as stump terms
If the length is 1, this value gets recycled for all columns of X.}

\item{num_cuts}{is a whole number of length 1 or p specifying how many cuts to make when making the stumps terms.
If the length is 1, this value gets recycled for all columns of X.
For entries corresponding to the indices where `include_stumps` is FALSE, these values are ignored.
We use the quantiles from each predictor when making the stumps splits, using `num_cuts` of them.
If `num_cuts = Inf`, then all values of the variables are used as split points.}

\item{...}{Other arguments to be passed to `veb_boost`}
}
\value{
A \code{VEB_Boost_Node} object with the fit
}
\description{
Wrapper for using VEB-Boost with the SER prior w/ stumps and/or linear terms
}
\details{
This function performs VEB-Boosting, where the prior to be used is the SER prior, and our predictors are either
i) the linear terms of X;
ii) the stumps made from the columns of X; or
iii) Both (i) and (ii)
}
\examples{
set.seed(1)
n = 1000
p = 1000
X = matrix(runif(n * p), nrow = n, ncol = p)
Y = rnorm(n, 5*sin(3*X[, 1]) + 2*(X[, 2]^2) + 3*X[, 3]*X[, 4])
veb.stumps.fit = veb_boost_stumps(X, Y, include_linear = TRUE, family = "gaussian")

}
